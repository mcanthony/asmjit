// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_BASE_STREAM_H
#define _ASMJIT_BASE_STREAM_H

#include "../build.h"
#if !defined(ASMJIT_DISABLE_COMPILER)

// [Dependencies - AsmJit]
#include "../base/assembler.h"
#include "../base/operand.h"

// [Api-Begin]
#include "../apibegin.h"

namespace asmjit {

// ============================================================================
// [Forward Declarations]
// ============================================================================

struct Compiler;
struct VarData;
struct VarState;
struct VarMap;

struct ASInst;
struct ASJump;
struct ASLabel;
struct ASSentinel;

//! \addtogroup asmjit_base_compiler
//! \{

// ============================================================================
// [asmjit::ASNodeType]
// ============================================================================

//! Type of \ref ASNode.
ASMJIT_ENUM(ASNodeType) {
  //! Invalid node (internal, don't use).
  kASNodeTypeNone = 0,

  // --------------------------------------------------------------------------
  // [Low-Level - Assembler / Compiler]
  // --------------------------------------------------------------------------

  //! Node is \ref ASInst or \ref ASJump.
  kASNodeTypeInst,
  //! Node is \ref ASData.
  kASNodeTypeData,
  //! Node is \ref ASAlign.
  kASNodeTypeAlign,
  //! Node is \ref ASLabel.
  kASNodeTypeLabel,
  //! Node is \ref ASComment.
  kASNodeTypeComment,
  //! Node is \ref ASSentinel.
  kASNodeTypeSentinel,

  // --------------------------------------------------------------------------
  // [High-Level - Compiler-Only]
  // --------------------------------------------------------------------------

  //! Node is \ref ASHint.
  kASNodeTypeHint,
  //! Node is \ref ASFunc.
  kASNodeTypeFunc,
  //! Node is \ref ASRet.
  kASNodeTypeRet,
  //! Node is \ref ASCall.
  kASNodeTypeCall,
  //! Node is \ref ASCallArg.
  kASNodeTypeCallArg
};

// ============================================================================
// [asmjit::ASNodeFlags]
// ============================================================================

ASMJIT_ENUM(ASNodeFlags) {
  //! Whether the node has been translated, thus contains only registers.
  kASNodeFlagIsTranslated = 0x0001,

  //! Whether the node was scheduled - possibly reordered, but basically this
  //! is a mark that is set by scheduler after the node has been visited.
  kASNodeFlagIsScheduled = 0x0002,

  //! Whether the node is informative only and can be safely removed.
  kASNodeFlagIsInformative = 0x0004,

  //! Whether the `ASInst` is a jump.
  kASNodeFlagIsJmp = 0x0008,
  //! Whether the `ASInst` is a conditional jump.
  kASNodeFlagIsJcc = 0x0010,

  //! Whether the `ASInst` is an unconditinal jump or conditional jump that is
  //! likely to be taken.
  kASNodeFlagIsTaken = 0x0020,

  //! Whether the `ASNode` will return from a function.
  //!
  //! This flag is used by both `ASSentinel` and `ASRet`.
  kASNodeFlagIsRet = 0x0040,

  //! Whether the instruction is special.
  kASNodeFlagIsSpecial = 0x0080,

  //! Whether the instruction is an FPU instruction.
  kASNodeFlagIsFp = 0x0100
};

// ============================================================================
// [asmjit::ASNode]
// ============================================================================

//! Stream node.
//!
//! `Every` node represents an abstract instruction, directive, label, or
//! macro-instruction generated by the `Compiler`.
struct ASNode {
  ASMJIT_NO_COPY(ASNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASNode`.
  //!
  //! \note Always use compiler to create nodes.
  ASMJIT_INLINE ASNode(Compiler* compiler, uint32_t type); // Defined-Later.

  //! Destroy the `ASNode`.
  //!
  //! NOTE: Nodes are zone allocated, there should be no code in the destructor.
  ASMJIT_INLINE ~ASNode() {}

  // --------------------------------------------------------------------------
  // [Accessors - List]
  // --------------------------------------------------------------------------

  //! Get previous node in the compiler stream.
  ASMJIT_INLINE ASNode* getPrev() const { return _prev; }
  //! Get next node in the compiler stream.
  ASMJIT_INLINE ASNode* getNext() const { return _next; }

  // --------------------------------------------------------------------------
  // [Accessors - Comment]
  // --------------------------------------------------------------------------

  //! Get comment string.
  ASMJIT_INLINE const char* getComment() const { return _comment; }
  //! Set comment string to `str`.
  ASMJIT_INLINE void setComment(const char* comment) { _comment = comment; }

  // --------------------------------------------------------------------------
  // [Accessors - Type and Flags]
  // --------------------------------------------------------------------------

  //! Get the node type, see \ref ASNodeType.
  ASMJIT_INLINE uint32_t getType() const { return _type; }
  //! Get the node flags.
  ASMJIT_INLINE uint32_t getFlags() const { return _flags; }

  //! Get whether the instruction has flag `flag`.
  ASMJIT_INLINE bool hasFlag(uint32_t flag) const { return (static_cast<uint32_t>(_flags) & flag) != 0; }
  //! Set node flags to `flags`.
  ASMJIT_INLINE void setFlags(uint32_t flags) { _flags = static_cast<uint16_t>(flags); }
  //! Add instruction `flags`.
  ASMJIT_INLINE void orFlags(uint32_t flags) { _flags |= static_cast<uint16_t>(flags); }
  //! And instruction `flags`.
  ASMJIT_INLINE void andFlags(uint32_t flags) { _flags &= static_cast<uint16_t>(flags); }
  //! Clear instruction `flags`.
  ASMJIT_INLINE void andNotFlags(uint32_t flags) { _flags &= ~static_cast<uint16_t>(flags); }

  //! Get whether the node has beed fetched.
  ASMJIT_INLINE bool isFetched() const { return _flowId != 0; }
  //! Get whether the node has been translated.
  ASMJIT_INLINE bool isTranslated() const { return hasFlag(kASNodeFlagIsTranslated); }
  //! Get whether the node has been translated.
  ASMJIT_INLINE bool isScheduled() const { return hasFlag(kASNodeFlagIsScheduled); }
  //! Get whether the node is informative only (comment, hint).
  ASMJIT_INLINE bool isInformative() const { return hasFlag(kASNodeFlagIsInformative); }

  //! Whether the `ASInst` node is an unconditional jump.
  ASMJIT_INLINE bool isJmp() const { return hasFlag(kASNodeFlagIsJmp); }
  //! Whether the `ASInst` node is a conditional jump.
  ASMJIT_INLINE bool isJcc() const { return hasFlag(kASNodeFlagIsJcc); }
  //! Whether the `ASInst` node is a conditional/unconditional jump.
  ASMJIT_INLINE bool isJmpOrJcc() const { return hasFlag(kASNodeFlagIsJmp | kASNodeFlagIsJcc); }
  //! Whether the `ASInst` node is a return.
  ASMJIT_INLINE bool isRet() const { return hasFlag(kASNodeFlagIsRet); }

  //! Get whether the node is `ASInst` and the instruction is special.
  ASMJIT_INLINE bool isSpecial() const { return hasFlag(kASNodeFlagIsSpecial); }
  //! Get whether the node is `ASInst` and the instruction uses x87-FPU.
  ASMJIT_INLINE bool isFp() const { return hasFlag(kASNodeFlagIsFp); }

  // --------------------------------------------------------------------------
  // [Accessors - FlowId]
  // --------------------------------------------------------------------------

  //! Get flow index.
  ASMJIT_INLINE uint32_t getFlowId() const { return _flowId; }
  //! Set flow index.
  ASMJIT_INLINE void setFlowId(uint32_t flowId) { _flowId = flowId; }

  // --------------------------------------------------------------------------
  // [Accessors - TokenId]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE bool hasTokenId(uint32_t id) const { return _tokenId == id; }
  ASMJIT_INLINE uint32_t getTokenId() const { return _tokenId; }
  ASMJIT_INLINE void setTokenId(uint32_t id) { _tokenId = id; }

  // --------------------------------------------------------------------------
  // [Accessors - VarMap]
  // --------------------------------------------------------------------------

  //! Get whether node contains variable allocation instructions.
  ASMJIT_INLINE bool hasMap() const { return _map != NULL; }
  //! Get variable allocation instructions.
  ASMJIT_INLINE VarMap* getMap() const { return _map; }
  //! Get variable allocation instructions casted to `T*`.
  template<typename T>
  ASMJIT_INLINE T* getMap() const { return static_cast<T*>(_map); }
  //! Set variable allocation instructions.
  ASMJIT_INLINE void setMap(VarMap* map) { _map = map; }

  // --------------------------------------------------------------------------
  // [Accessors - VarState]
  // --------------------------------------------------------------------------

  //! Get whether the node has an associated `VarState`.
  ASMJIT_INLINE bool hasState() const { return _state != NULL; }
  //! Get node state.
  ASMJIT_INLINE VarState* getState() const { return _state; }
  //! Get node state casted to `T*`.
  template<typename T>
  ASMJIT_INLINE T* getState() const { return static_cast<T*>(_state); }
  //! Set node state.
  ASMJIT_INLINE void setState(VarState* state) { _state = state; }

  // --------------------------------------------------------------------------
  // [Accessors - Liveness]
  // --------------------------------------------------------------------------

  //! Get whether the node has variable liveness bits.
  ASMJIT_INLINE bool hasLiveness() const { return _liveness != NULL; }
  //! Get variable liveness bits.
  ASMJIT_INLINE BitArray* getLiveness() const { return _liveness; }
  //! Set variable liveness bits.
  ASMJIT_INLINE void setLiveness(BitArray* liveness) { _liveness = liveness; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Previous node.
  ASNode* _prev;
  //! Next node.
  ASNode* _next;

  //! Node type, see \ref ASNodeType.
  uint8_t _type;
  //! Count of operands (if the node has operands, otherwise zero).
  uint8_t _opCount;
  //! Node flags, different meaning for every type of the node.
  uint16_t _flags;

  //! Flow index.
  uint32_t _flowId;

  //! Processing token ID.
  //!
  //! Used by some algorithms to mark nodes as visited. If the token is
  //! generated in an incrementing way the visitor can just mark nodes it
  //! visits and them compare the `ASNode`s token with it's local token.
  //! If they match the node has been visited already. Then the visitor
  //! doesn't need to clean things up as the next time the token will be
  //! different.
  uint32_t _tokenId;

  // TODO: 32-bit gap

  //! Inline comment string, initially set to NULL.
  const char* _comment;

  //! Variable mapping (VarAttr to VarData), initially NULL, filled during
  //! fetch phase.
  VarMap* _map;

  //! Variable liveness bits (initially NULL, filled by analysis phase).
  BitArray* _liveness;

  //! Saved state.
  //!
  //! Initially NULL, not all nodes have saved state, only branch/flow control
  //! nodes.
  VarState* _state;
};

// ============================================================================
// [asmjit::ASInst]
// ============================================================================

//! Instruction node (Stream).
//!
//! Wraps an instruction with its options and operands.
struct ASInst : public ASNode {
  ASMJIT_NO_COPY(ASInst)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASInst` instance.
  ASMJIT_INLINE ASInst(Compiler* compiler, uint32_t instId, uint32_t instOptions, Operand* opList, uint32_t opCount)
    : ASNode(compiler, kASNodeTypeInst) {

    _instId = static_cast<uint16_t>(instId);
    _reserved = 0;
    _instOptions = instOptions;

    _opCount = static_cast<uint8_t>(opCount);
    _opList = opList;

    _updateMemOp();
  }

  //! Destroy the `ASInst` instance.
  ASMJIT_INLINE ~ASInst() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the instruction id, see `X86InstId`.
  ASMJIT_INLINE uint32_t getInstId() const { return _instId; }
  //! Set the instruction id to `instId`.
  //!
  //! NOTE: Please do not modify instruction code if you don't know what you
  //! are doing. Incorrect instruction code and/or operands can cause random
  //! errors in production builds and will most probably trigger assertion
  //! failures in debug builds.
  ASMJIT_INLINE void setInstId(uint32_t instId) { _instId = static_cast<uint16_t>(instId); }

  //! Whether the instruction is either a jump or a conditional jump likely to
  //! be taken.
  ASMJIT_INLINE bool isTaken() const { return hasFlag(kASNodeFlagIsTaken); }

  //! Get emit options.
  ASMJIT_INLINE uint32_t getOptions() const { return _instOptions; }
  //! Set emit options.
  ASMJIT_INLINE void setOptions(uint32_t options) { _instOptions = options; }
  //! Add emit options.
  ASMJIT_INLINE void addOptions(uint32_t options) { _instOptions |= options; }
  //! Mask emit options.
  ASMJIT_INLINE void andOptions(uint32_t options) { _instOptions &= options; }
  //! Clear emit options.
  ASMJIT_INLINE void delOptions(uint32_t options) { _instOptions &= ~options; }

  //! Get operands count.
  ASMJIT_INLINE uint32_t getOpCount() const { return _opCount; }
  //! Get operands list.
  ASMJIT_INLINE Operand* getOpList() { return _opList; }
  //! \overload
  ASMJIT_INLINE const Operand* getOpList() const { return _opList; }

  //! Get whether the instruction contains a memory operand.
  ASMJIT_INLINE bool hasMemOp() const { return _memOpIndex != 0xFF; }
  //! Get memory operand.
  //!
  //! NOTE: Can only be called if the instruction has such operand,
  //! see `hasMemOp()`.
  ASMJIT_INLINE BaseMem* getMemOp() const {
    ASMJIT_ASSERT(hasMemOp());
    return static_cast<BaseMem*>(&_opList[_memOpIndex]);
  }
  //! \overload
  template<typename T>
  ASMJIT_INLINE T* getMemOp() const {
    ASMJIT_ASSERT(hasMemOp());
    return static_cast<T*>(&_opList[_memOpIndex]);
  }

  //! Set memory operand index, `0xFF` means no memory operand.
  ASMJIT_INLINE void setMemOpIndex(uint32_t index) { _memOpIndex = static_cast<uint8_t>(index); }
  //! Reset memory operand index to `0xFF` (no operand).
  ASMJIT_INLINE void resetMemOpIndex() { _memOpIndex = 0xFF; }

  // --------------------------------------------------------------------------
  // [Utils]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE void _updateMemOp() {
    Operand* opList = getOpList();
    uint32_t opCount = getOpCount();

    uint32_t i;
    for (i = 0; i < opCount; i++)
      if (opList[i].isMem())
        goto _Update;
    i = 0xFF;

_Update:
    setMemOpIndex(i);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Instruction ID, see `InstId`.
  uint16_t _instId;
  //! \internal
  uint8_t _memOpIndex;
  //! \internal
  uint8_t _reserved;
  //! Instruction options, see `InstOptions`.
  uint32_t _instOptions;

  //! Operands list.
  Operand* _opList;
};

// ============================================================================
// [asmjit::ASJump]
// ============================================================================

//! Jump node (Stream).
//!
//! Extension of `ASInst` node, which stores more information about the jump.
struct ASJump : public ASInst {
  ASMJIT_NO_COPY(ASJump)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE ASJump(Compiler* compiler, uint32_t code, uint32_t options, Operand* opList, uint32_t opCount) :
    ASInst(compiler, code, options, opList, opCount) {}
  ASMJIT_INLINE ~ASJump() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE ASLabel* getTarget() const { return _target; }
  ASMJIT_INLINE ASJump* getJumpNext() const { return _jumpNext; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Target node.
  ASLabel* _target;
  //! Next jump to the same target in a single linked-list.
  ASJump* _jumpNext;
};

// ============================================================================
// [asmjit::ASData]
// ============================================================================

//! Data node (Stream).
//!
//! Wraps `.data` directive. The node contains data that will be placed at the
//! node's position in the assembler stream. The data is considered to be RAW;
//! no analysis nor byte-order conversion is performed on RAW data.
struct ASData : public ASNode {
  ASMJIT_NO_COPY(ASData)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  enum { kInlineBufferSize = 12 };

  //! Create a new `ASData` instance.
  ASMJIT_INLINE ASData(Compiler* compiler, void* data, uint32_t size)
    : ASNode(compiler, kASNodeTypeData) {

    _size = size;
    if (size <= kInlineBufferSize) {
      if (data != NULL)
        ::memcpy(_data.buf, data, size);
    }
    else {
      _data.ptr = static_cast<uint8_t*>(data);
    }
  }

  //! Destroy the `ASData` instance.
  ASMJIT_INLINE ~ASData() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get size of the data.
  uint32_t getSize() const { return _size; }
  //! Get pointer to the data.
  uint8_t* getData() const { return _size <= kInlineBufferSize ? const_cast<uint8_t*>(_data.buf) : _data.ptr; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    //! data buffer.
    uint8_t buf[kInlineBufferSize];
    //! Data buffer.
    uint8_t* ptr;
  } _data;

  //! Size of the data.
  uint32_t _size;
};

// ============================================================================
// [asmjit::ASAlign]
// ============================================================================

//! Align node (Stream).
//!
//! Wraps `.align` directive.
struct ASAlign : public ASNode {
  ASMJIT_NO_COPY(ASAlign)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASAlign` instance.
  ASMJIT_INLINE ASAlign(Compiler* compiler, uint32_t alignMode, uint32_t offset)
    : ASNode(compiler, kASNodeTypeAlign) {

    _alignMode = alignMode;
    _offset = offset;
  }

  //! Destroy the `ASAlign` instance.
  ASMJIT_INLINE ~ASAlign() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get align mode.
  ASMJIT_INLINE uint32_t getAlignMode() const { return _alignMode; }
  //! Set align mode.
  ASMJIT_INLINE void setAlignMode(uint32_t alignMode) { _alignMode = alignMode; }

  //! Get align offset in bytes.
  ASMJIT_INLINE uint32_t getOffset() const { return _offset; }
  //! Set align offset in bytes to `offset`.
  ASMJIT_INLINE void setOffset(uint32_t offset) { _offset = offset; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Align mode, see \ref AlignMode.
  uint32_t _alignMode;
  //! Align offset (in bytes).
  uint32_t _offset;
};

// ============================================================================
// [asmjit::ASLabel]
// ============================================================================

//! label node (Stream).
struct ASLabel : public ASNode {
  ASMJIT_NO_COPY(ASLabel)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASLabel` instance.
  ASMJIT_INLINE ASLabel(Compiler* compiler, uint32_t labelId)
    : ASNode(compiler, kASNodeTypeLabel) {

    _id = labelId;
    _numRefs = 0;
    _offset = -1;
    _from = NULL;
  }

  //! Destroy the `ASLabel` instance.
  ASMJIT_INLINE ~ASLabel() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get target label.
  ASMJIT_INLINE Label getLabel() const { return Label(_id); }
  //! Get target label id.
  ASMJIT_INLINE uint32_t getLabelId() const { return _id; }

  //! Get first jmp instruction.
  ASMJIT_INLINE ASJump* getFrom() const { return _from; }

  //! Get whether the node has assigned state.
  ASMJIT_INLINE bool hasState() const { return _state != NULL; }
  //! Get state for this target.
  ASMJIT_INLINE VarState* getState() const { return _state; }
  //! Set state for this target.
  ASMJIT_INLINE void setState(VarState* state) { _state = state; }

  //! Get number of jumps to this target.
  ASMJIT_INLINE uint32_t getNumRefs() const { return _numRefs; }
  //! Set number of jumps to this target.
  ASMJIT_INLINE void setNumRefs(uint32_t i) { _numRefs = i; }

  //! Add number of jumps to this target.
  ASMJIT_INLINE void addNumRefs(uint32_t i = 1) { _numRefs += i; }
  //! Subtract number of jumps to this target.
  ASMJIT_INLINE void subNumRefs(uint32_t i = 1) { _numRefs -= i; }

  //! Get the label offset.
  //!
  //! \note Only valid after the content has been serialized to the `Assembler`.
  ASMJIT_INLINE intptr_t getOffset() const { return _offset; }

  //! Set the label offset.
  ASMJIT_INLINE void setOffset(intptr_t offset) { _offset = offset; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Label id.
  uint32_t _id;
  //! Count of jumps here.
  uint32_t _numRefs;

  //! Label offset, after serialization.
  intptr_t _offset;
  //! First jump instruction that points to this target (label).
  ASJump* _from;
};

// ============================================================================
// [asmjit::ASComment]
// ============================================================================

//! Comment node (Stream).
struct ASComment : public ASNode {
  ASMJIT_NO_COPY(ASComment)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASComment` instance.
  ASMJIT_INLINE ASComment(Compiler* compiler, const char* comment)
    : ASNode(compiler, kASNodeTypeComment) {

    orFlags(kASNodeFlagIsInformative);
    _comment = comment;
  }

  //! Destroy the `ASComment` instance.
  ASMJIT_INLINE ~ASComment() {}
};

// ============================================================================
// [asmjit::ASSentinel]
// ============================================================================

//! Sentinel node (Stream).
struct ASSentinel : public ASNode {
  ASMJIT_NO_COPY(ASSentinel)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASSentinel` instance.
  ASMJIT_INLINE ASSentinel(Compiler* compiler)
    : ASNode(compiler, kASNodeTypeSentinel) {
    _flags |= kASNodeFlagIsRet;
  }

  //! Destroy the `ASSentinel` instance.
  ASMJIT_INLINE ~ASSentinel() {}
};

// ============================================================================
// [asmjit::ASHint]
// ============================================================================

//! Hint node.
struct ASHint : public ASNode {
  ASMJIT_NO_COPY(ASHint)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASHint` instance.
  ASMJIT_INLINE ASHint(Compiler* compiler, VarData* vd, uint32_t hint, uint32_t value)
    : ASNode(compiler, kASNodeTypeHint) {

    orFlags(kASNodeFlagIsInformative);
    _vd = vd;
    _hint = hint;
    _value = value;
  }

  //! Destroy the `ASHint` instance.
  ASMJIT_INLINE ~ASHint() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get variable.
  ASMJIT_INLINE VarData* getVd() const { return _vd; }

  //! Get hint it (see `kVarHint)`.
  ASMJIT_INLINE uint32_t getHint() const{ return _hint; }
  //! Set hint it (see `kVarHint)`.
  ASMJIT_INLINE void setHint(uint32_t hint) { _hint = hint; }

  //! Get hint value.
  ASMJIT_INLINE uint32_t getValue() const { return _value; }
  //! Set hint value.
  ASMJIT_INLINE void setValue(uint32_t value) { _value = value; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Variable.
  VarData* _vd;
  //! Hint id.
  uint32_t _hint;
  //! Value.
  uint32_t _value;
};

// ============================================================================
// [asmjit::ASFunc]
// ============================================================================

//! Function node (Stream).
struct ASFunc : public ASNode {
  ASMJIT_NO_COPY(ASFunc)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASFunc` instance.
  //!
  //! Always use `Compiler::addFunc()` to create a `ASFunc` instance.
  ASMJIT_INLINE ASFunc(Compiler* compiler)
    : ASNode(compiler, kASNodeTypeFunc),
      _entryNode(NULL),
      _exitNode(NULL),
      _decl(NULL),
      _end(NULL),
      _args(NULL),
      _funcHints(Utils::mask(kFuncHintNaked)),
      _funcFlags(0),
      _expectedStackAlignment(0),
      _requiredStackAlignment(0),
      _redZoneSize(0),
      _spillZoneSize(0),
      _argStackSize(0),
      _memStackSize(0),
      _callStackSize(0) {}

  //! Destroy the `ASFunc` instance.
  ASMJIT_INLINE ~ASFunc() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get function entry `ASLabel`.
  ASMJIT_INLINE ASLabel* getEntryNode() const { return _entryNode; }
  //! Get function exit `ASLabel`.
  ASMJIT_INLINE ASLabel* getExitNode() const { return _exitNode; }

  //! Get function entry label.
  ASMJIT_INLINE Label getEntryLabel() const { return _entryNode->getLabel(); }
  //! Get function exit label.
  ASMJIT_INLINE Label getExitLabel() const { return _exitNode->getLabel(); }

  //! Get the function end sentinel.
  ASMJIT_INLINE ASSentinel* getEnd() const { return _end; }
  //! Get function declaration.
  ASMJIT_INLINE FuncDecl* getDecl() const { return _decl; }

  //! Get arguments count.
  ASMJIT_INLINE uint32_t getNumArgs() const { return _decl->getNumArgs(); }
  //! Get arguments list.
  ASMJIT_INLINE VarData** getArgs() const { return _args; }

  //! Get argument at `i`.
  ASMJIT_INLINE VarData* getArg(uint32_t i) const {
    ASMJIT_ASSERT(i < getNumArgs());
    return _args[i];
  }

  //! Set argument at `i`.
  ASMJIT_INLINE void setArg(uint32_t i, VarData* vd) {
    ASMJIT_ASSERT(i < getNumArgs());
    _args[i] = vd;
  }

  //! Reset argument at `i`.
  ASMJIT_INLINE void resetArg(uint32_t i) {
    ASMJIT_ASSERT(i < getNumArgs());
    _args[i] = NULL;
  }

  //! Get function hints.
  ASMJIT_INLINE uint32_t getFuncHints() const { return _funcHints; }
  //! Get function flags.
  ASMJIT_INLINE uint32_t getFuncFlags() const { return _funcFlags; }

  //! Get whether the _funcFlags has `flag`
  ASMJIT_INLINE bool hasFuncFlag(uint32_t flag) const { return (_funcFlags & flag) != 0; }
  //! Set function `flag`.
  ASMJIT_INLINE void addFuncFlags(uint32_t flags) { _funcFlags |= flags; }
  //! Clear function `flag`.
  ASMJIT_INLINE void clearFuncFlags(uint32_t flags) { _funcFlags &= ~flags; }

  //! Get whether the function is naked.
  ASMJIT_INLINE bool isNaked() const { return hasFuncFlag(kFuncFlagIsNaked); }
  //! Get whether the function is also a caller.
  ASMJIT_INLINE bool isCaller() const { return hasFuncFlag(kFuncFlagIsCaller); }
  //! Get whether the required stack alignment is lower than expected one,
  //! thus it has to be aligned manually.
  ASMJIT_INLINE bool isStackMisaligned() const { return hasFuncFlag(kFuncFlagIsStackMisaligned); }
  //! Get whether the stack pointer is adjusted inside function prolog/epilog.
  ASMJIT_INLINE bool isStackAdjusted() const { return hasFuncFlag(kFuncFlagIsStackAdjusted); }

  //! Get whether the function is finished.
  ASMJIT_INLINE bool isFinished() const { return hasFuncFlag(kFuncFlagIsFinished); }

  //! Get expected stack alignment.
  ASMJIT_INLINE uint32_t getExpectedStackAlignment() const { return _expectedStackAlignment; }
  //! Set expected stack alignment.
  ASMJIT_INLINE void setExpectedStackAlignment(uint32_t alignment) { _expectedStackAlignment = alignment; }

  //! Get required stack alignment.
  ASMJIT_INLINE uint32_t getRequiredStackAlignment() const { return _requiredStackAlignment; }
  //! Set required stack alignment.
  ASMJIT_INLINE void setRequiredStackAlignment(uint32_t alignment) { _requiredStackAlignment = alignment; }

  //! Update required stack alignment so it's not lower than expected
  //! stack alignment.
  ASMJIT_INLINE void updateRequiredStackAlignment() {
    if (_requiredStackAlignment <= _expectedStackAlignment) {
      _requiredStackAlignment = _expectedStackAlignment;
      clearFuncFlags(kFuncFlagIsStackMisaligned);
    }
    else {
      addFuncFlags(kFuncFlagIsStackMisaligned);
    }
  }

  //! Set stack "Red Zone" size.
  ASMJIT_INLINE uint32_t getRedZoneSize() const { return _redZoneSize; }
  //! Get stack "Red Zone" size.
  ASMJIT_INLINE void setRedZoneSize(uint32_t s) { _redZoneSize = static_cast<uint16_t>(s); }

  //! Set stack "Spill Zone" size.
  ASMJIT_INLINE uint32_t getSpillZoneSize() const { return _spillZoneSize; }
  //! Get stack "Spill Zone" size.
  ASMJIT_INLINE void setSpillZoneSize(uint32_t s) { _spillZoneSize = static_cast<uint16_t>(s); }

  //! Get stack size used by function arguments.
  ASMJIT_INLINE uint32_t getArgStackSize() const { return _argStackSize; }

  //! Get stack size used by variables and memory allocated on the stack.
  ASMJIT_INLINE uint32_t getMemStackSize() const { return _memStackSize; }

  //! Get stack size used by function calls.
  ASMJIT_INLINE uint32_t getCallStackSize() const { return _callStackSize; }
  //! Merge stack size used by function call with `s`.
  ASMJIT_INLINE void mergeCallStackSize(uint32_t s) { if (_callStackSize < s) _callStackSize = s; }

  // --------------------------------------------------------------------------
  // [Hints]
  // --------------------------------------------------------------------------

  //! Set function hint.
  ASMJIT_INLINE void setHint(uint32_t hint, uint32_t value) {
    ASMJIT_ASSERT(hint <= 31);
    ASMJIT_ASSERT(value <= 1);

    _funcHints &= ~(1     << hint);
    _funcHints |=  (value << hint);
  }

  //! Get function hint.
  ASMJIT_INLINE uint32_t getHint(uint32_t hint) const {
    ASMJIT_ASSERT(hint <= 31);
    return (_funcHints >> hint) & 0x1;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Function entry.
  ASLabel* _entryNode;
  //! Function exit.
  ASLabel* _exitNode;

  //! Function declaration.
  FuncDecl* _decl;
  //! Function end.
  ASSentinel* _end;

  //! Arguments list as `VarData`.
  VarData** _args;

  //! Function hints;
  uint32_t _funcHints;
  //! Function flags.
  uint32_t _funcFlags;

  //! Expected stack alignment (we depend on this value).
  //!
  //! \note It can be global alignment given by the OS or described by the
  //! target platform ABI.
  uint32_t _expectedStackAlignment;
  //! Required stack alignment (required by SIMD instructions).
  uint32_t _requiredStackAlignment;

  //! The "Red Zone" size - count of bytes which might be accessed by a left
  //! function without adjusting the stack pointer (`esp` or `rsp`) (AMD64 ABI).
  uint16_t _redZoneSize;

  //! The "Spill Zone" size - count of bytes after the function return address
  //! that can be used by the function to spill variables in (WIN64 ABI).
  uint16_t _spillZoneSize;

  //! Stack size needed for function arguments.
  uint32_t _argStackSize;
  //! Stack size needed for all variables and memory allocated on the stack.
  uint32_t _memStackSize;
  //! Stack size needed to call other functions.
  uint32_t _callStackSize;
};

// ============================================================================
// [asmjit::ASRet]
// ============================================================================

//! Return node (Stream).
struct ASRet : public ASNode {
  ASMJIT_NO_COPY(ASRet)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASRet` instance.
  ASMJIT_INLINE ASRet(Compiler* compiler, const Operand& o0, const Operand& o1)
    : ASNode(compiler, kASNodeTypeRet) {

    _flags |= kASNodeFlagIsRet;
    _ret[0] = o0;
    _ret[1] = o1;
  }

  //! Destroy the `ASRet` instance.
  ASMJIT_INLINE ~ASRet() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the first return operand.
  ASMJIT_INLINE Operand& getFirst() { return _ret[0]; }
  //! \overload
  ASMJIT_INLINE const Operand& getFirst() const { return _ret[0]; }

  //! Get the second return operand.
  ASMJIT_INLINE Operand& getSecond() { return _ret[1]; }
   //! \overload
  ASMJIT_INLINE const Operand& getSecond() const { return _ret[1]; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Ret operand(s).
  Operand _ret[2];
};

// ============================================================================
// [asmjit::ASCall]
// ============================================================================

//! Call node (Stream).
struct ASCall : public ASNode {
  ASMJIT_NO_COPY(ASCall)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASCall` instance.
  ASMJIT_INLINE ASCall(Compiler* compiler, const Operand& target)
    : ASNode(compiler, kASNodeTypeCall),
      _decl(NULL),
      _target(target),
      _args(NULL) {}

  //! Destroy the `ASCall` instance.
  ASMJIT_INLINE ~ASCall() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get function declaration.
  ASMJIT_INLINE FuncDecl* getDecl() const { return _decl; }

  //! Get target operand.
  ASMJIT_INLINE Operand& getTarget() { return _target; }
  //! \overload
  ASMJIT_INLINE const Operand& getTarget() const  { return _target; }

  //! Get return at `i`.
  ASMJIT_INLINE Operand& getRet(uint32_t i = 0) {
    ASMJIT_ASSERT(i < 2);
    return _ret[i];
  }
  //! \overload
  ASMJIT_INLINE const Operand& getRet(uint32_t i = 0) const  {
    ASMJIT_ASSERT(i < 2);
    return _ret[i];
  }

  //! Get argument at `i`.
  ASMJIT_INLINE Operand& getArg(uint32_t i) {
    ASMJIT_ASSERT(i < kFuncArgCountLoHi);
    return _args[i];
  }
  //! \overload
  ASMJIT_INLINE const Operand& getArg(uint32_t i) const  {
    ASMJIT_ASSERT(i < kFuncArgCountLoHi);
    return _args[i];
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Function declaration.
  FuncDecl* _decl;

  //! Target (address of function, register, label, ...).
  Operand _target;
  //! Return.
  Operand _ret[2];
  //! Arguments.
  Operand* _args;
};

// ============================================================================
// [asmjit::ASCallArg]
// ============================================================================

//! Function call's argument node (Stream).
struct ASCallArg : public ASNode {
  ASMJIT_NO_COPY(ASCallArg)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ASCallArg` instance.
  ASMJIT_INLINE ASCallArg(Compiler* compiler, ASCall* call, VarData* sVd, VarData* cVd)
    : ASNode(compiler, kASNodeTypeCallArg),
      _call(call),
      _sVd(sVd),
      _cVd(cVd),
      _args(0) {}

  //! Destroy the `ASCallArg` instance.
  ASMJIT_INLINE ~ASCallArg() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the associated function-call.
  ASMJIT_INLINE ASCall* getCall() const { return _call; }
  //! Get source variable.
  ASMJIT_INLINE VarData* getSVd() const { return _sVd; }
  //! Get conversion variable.
  ASMJIT_INLINE VarData* getCVd() const { return _cVd; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Associated `ASCall`.
  ASCall* _call;
  //! Source variable.
  VarData* _sVd;
  //! Temporary variable used for conversion (or NULL).
  VarData* _cVd;

  //! Affected arguments bit-array.
  uint32_t _args;
};

// ============================================================================
// [asmjit::Stream]
// ============================================================================



//! \}

} // asmjit namespace

// [Api-End]
#include "../apiend.h"

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_BASE_STREAM_H
